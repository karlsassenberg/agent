// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: command.proto

package proto

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	events "github.com/nginx/agent/sdk/v2/proto/events"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Command type enum
type Command_CommandType int32

const (
	// All commands default to normal
	Command_NORMAL Command_CommandType = 0
	// The download type is used when sending NginxConfig from the management server to the agent.
	// It is used to instruct the agent to download the NGINX config from the management server.
	Command_DOWNLOAD Command_CommandType = 1
	// The upload type is used when sending NginxConfig from the agent to the management server.
	// It is used to instruct the agent to upload the NGINX config from the agent.
	// This will be implemented in a future release.
	Command_UPLOAD Command_CommandType = 2
)

var Command_CommandType_name = map[int32]string{
	0: "NORMAL",
	1: "DOWNLOAD",
	2: "UPLOAD",
}

var Command_CommandType_value = map[string]int32{
	"NORMAL":   0,
	"DOWNLOAD": 1,
	"UPLOAD":   2,
}

func (x Command_CommandType) String() string {
	return proto.EnumName(Command_CommandType_name, int32(x))
}

func (Command_CommandType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{0, 0}
}

// Command status enum
type CommandStatusResponse_CommandStatus int32

const (
	// Unknown status of command
	CommandStatusResponse_CMD_UNKNOWN CommandStatusResponse_CommandStatus = 0
	// Command was successful
	CommandStatusResponse_CMD_OK CommandStatusResponse_CommandStatus = 1
	// Command failed
	CommandStatusResponse_CMD_ERROR CommandStatusResponse_CommandStatus = 2
)

var CommandStatusResponse_CommandStatus_name = map[int32]string{
	0: "CMD_UNKNOWN",
	1: "CMD_OK",
	2: "CMD_ERROR",
}

var CommandStatusResponse_CommandStatus_value = map[string]int32{
	"CMD_UNKNOWN": 0,
	"CMD_OK":      1,
	"CMD_ERROR":   2,
}

func (x CommandStatusResponse_CommandStatus) String() string {
	return proto.EnumName(CommandStatusResponse_CommandStatus_name, int32(x))
}

func (CommandStatusResponse_CommandStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{1, 0}
}

// Command error code enum
type CommandStatusResponse_CommandErrorCode int32

const (
	// No Error (This is the default value)
	CommandStatusResponse_ERR_OK CommandStatusResponse_CommandErrorCode = 0
	// Unknown error
	CommandStatusResponse_ERR_UNKNOWN CommandStatusResponse_CommandErrorCode = 1
)

var CommandStatusResponse_CommandErrorCode_name = map[int32]string{
	0: "ERR_OK",
	1: "ERR_UNKNOWN",
}

var CommandStatusResponse_CommandErrorCode_value = map[string]int32{
	"ERR_OK":      0,
	"ERR_UNKNOWN": 1,
}

func (x CommandStatusResponse_CommandErrorCode) String() string {
	return proto.EnumName(CommandStatusResponse_CommandErrorCode_name, int32(x))
}

func (CommandStatusResponse_CommandErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{1, 1}
}

// NGINX configuration status enum
type NginxConfigStatus_Status int32

const (
	// The configuration is still in the process of being applied.
	NginxConfigStatus_PENDING NginxConfigStatus_Status = 0
	// The configuration has being successfully applied.
	NginxConfigStatus_OK NginxConfigStatus_Status = 1
	// The configuration has failed to be applied
	NginxConfigStatus_ERROR NginxConfigStatus_Status = 2
)

var NginxConfigStatus_Status_name = map[int32]string{
	0: "PENDING",
	1: "OK",
	2: "ERROR",
}

var NginxConfigStatus_Status_value = map[string]int32{
	"PENDING": 0,
	"OK":      1,
	"ERROR":   2,
}

func (x NginxConfigStatus_Status) String() string {
	return proto.EnumName(NginxConfigStatus_Status_name, int32(x))
}

func (NginxConfigStatus_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{4, 0}
}

// Transfer status enum
type UploadStatus_TransferStatus int32

const (
	// Unknown status
	UploadStatus_UNKNOWN UploadStatus_TransferStatus = 0
	// Upload was successful
	UploadStatus_OK UploadStatus_TransferStatus = 1
	// Upload failed
	UploadStatus_FAILED UploadStatus_TransferStatus = 2
)

var UploadStatus_TransferStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "OK",
	2: "FAILED",
}

var UploadStatus_TransferStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"OK":      1,
	"FAILED":  2,
}

func (x UploadStatus_TransferStatus) String() string {
	return proto.EnumName(UploadStatus_TransferStatus_name, int32(x))
}

func (UploadStatus_TransferStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{9, 0}
}

// Represents a command message, which is used for communication between the management server and the agent.
type Command struct {
	// Provides metadata information associated with the command
	Meta *Metadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta"`
	// Used to determine the type of command
	Type Command_CommandType `protobuf:"varint,2,opt,name=type,proto3,enum=f5.nginx.agent.sdk.Command_CommandType" json:"type"`
	// Types that are valid to be assigned to Data:
	//	*Command_CmdStatus
	//	*Command_NginxConfig
	//	*Command_NginxConfigResponse
	//	*Command_AgentConnectRequest
	//	*Command_AgentConnectResponse
	//	*Command_AgentConfigRequest
	//	*Command_AgentConfig
	//	*Command_DataplaneStatus
	//	*Command_EventReport
	//	*Command_DataplaneSoftwareDetails
	//	*Command_DataplaneUpdate
	Data                 isCommand_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{0}
}
func (m *Command) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Command.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return m.Size()
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

type isCommand_Data interface {
	isCommand_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Command_CmdStatus struct {
	CmdStatus *CommandStatusResponse `protobuf:"bytes,3,opt,name=cmd_status,json=cmdStatus,proto3,oneof"`
}
type Command_NginxConfig struct {
	NginxConfig *NginxConfig `protobuf:"bytes,4,opt,name=nginx_config,json=nginxConfig,proto3,oneof"`
}
type Command_NginxConfigResponse struct {
	NginxConfigResponse *NginxConfigResponse `protobuf:"bytes,5,opt,name=nginx_config_response,json=nginxConfigResponse,proto3,oneof"`
}
type Command_AgentConnectRequest struct {
	AgentConnectRequest *AgentConnectRequest `protobuf:"bytes,6,opt,name=agent_connect_request,json=agentConnectRequest,proto3,oneof"`
}
type Command_AgentConnectResponse struct {
	AgentConnectResponse *AgentConnectResponse `protobuf:"bytes,7,opt,name=agent_connect_response,json=agentConnectResponse,proto3,oneof"`
}
type Command_AgentConfigRequest struct {
	AgentConfigRequest *AgentConfigRequest `protobuf:"bytes,8,opt,name=agent_config_request,json=agentConfigRequest,proto3,oneof"`
}
type Command_AgentConfig struct {
	AgentConfig *AgentConfig `protobuf:"bytes,9,opt,name=agent_config,json=agentConfig,proto3,oneof"`
}
type Command_DataplaneStatus struct {
	DataplaneStatus *DataplaneStatus `protobuf:"bytes,11,opt,name=dataplane_status,json=dataplaneStatus,proto3,oneof"`
}
type Command_EventReport struct {
	EventReport *events.EventReport `protobuf:"bytes,12,opt,name=event_report,json=eventReport,proto3,oneof"`
}
type Command_DataplaneSoftwareDetails struct {
	DataplaneSoftwareDetails *DataplaneSoftwareDetails `protobuf:"bytes,13,opt,name=dataplane_software_details,json=dataplaneSoftwareDetails,proto3,oneof"`
}
type Command_DataplaneUpdate struct {
	DataplaneUpdate *DataplaneUpdate `protobuf:"bytes,14,opt,name=dataplane_update,json=dataplaneUpdate,proto3,oneof"`
}

func (*Command_CmdStatus) isCommand_Data()                {}
func (*Command_NginxConfig) isCommand_Data()              {}
func (*Command_NginxConfigResponse) isCommand_Data()      {}
func (*Command_AgentConnectRequest) isCommand_Data()      {}
func (*Command_AgentConnectResponse) isCommand_Data()     {}
func (*Command_AgentConfigRequest) isCommand_Data()       {}
func (*Command_AgentConfig) isCommand_Data()              {}
func (*Command_DataplaneStatus) isCommand_Data()          {}
func (*Command_EventReport) isCommand_Data()              {}
func (*Command_DataplaneSoftwareDetails) isCommand_Data() {}
func (*Command_DataplaneUpdate) isCommand_Data()          {}

func (m *Command) GetData() isCommand_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Command) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Command) GetType() Command_CommandType {
	if m != nil {
		return m.Type
	}
	return Command_NORMAL
}

func (m *Command) GetCmdStatus() *CommandStatusResponse {
	if x, ok := m.GetData().(*Command_CmdStatus); ok {
		return x.CmdStatus
	}
	return nil
}

func (m *Command) GetNginxConfig() *NginxConfig {
	if x, ok := m.GetData().(*Command_NginxConfig); ok {
		return x.NginxConfig
	}
	return nil
}

func (m *Command) GetNginxConfigResponse() *NginxConfigResponse {
	if x, ok := m.GetData().(*Command_NginxConfigResponse); ok {
		return x.NginxConfigResponse
	}
	return nil
}

func (m *Command) GetAgentConnectRequest() *AgentConnectRequest {
	if x, ok := m.GetData().(*Command_AgentConnectRequest); ok {
		return x.AgentConnectRequest
	}
	return nil
}

func (m *Command) GetAgentConnectResponse() *AgentConnectResponse {
	if x, ok := m.GetData().(*Command_AgentConnectResponse); ok {
		return x.AgentConnectResponse
	}
	return nil
}

func (m *Command) GetAgentConfigRequest() *AgentConfigRequest {
	if x, ok := m.GetData().(*Command_AgentConfigRequest); ok {
		return x.AgentConfigRequest
	}
	return nil
}

func (m *Command) GetAgentConfig() *AgentConfig {
	if x, ok := m.GetData().(*Command_AgentConfig); ok {
		return x.AgentConfig
	}
	return nil
}

func (m *Command) GetDataplaneStatus() *DataplaneStatus {
	if x, ok := m.GetData().(*Command_DataplaneStatus); ok {
		return x.DataplaneStatus
	}
	return nil
}

func (m *Command) GetEventReport() *events.EventReport {
	if x, ok := m.GetData().(*Command_EventReport); ok {
		return x.EventReport
	}
	return nil
}

func (m *Command) GetDataplaneSoftwareDetails() *DataplaneSoftwareDetails {
	if x, ok := m.GetData().(*Command_DataplaneSoftwareDetails); ok {
		return x.DataplaneSoftwareDetails
	}
	return nil
}

func (m *Command) GetDataplaneUpdate() *DataplaneUpdate {
	if x, ok := m.GetData().(*Command_DataplaneUpdate); ok {
		return x.DataplaneUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Command) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Command_OneofMarshaler, _Command_OneofUnmarshaler, _Command_OneofSizer, []interface{}{
		(*Command_CmdStatus)(nil),
		(*Command_NginxConfig)(nil),
		(*Command_NginxConfigResponse)(nil),
		(*Command_AgentConnectRequest)(nil),
		(*Command_AgentConnectResponse)(nil),
		(*Command_AgentConfigRequest)(nil),
		(*Command_AgentConfig)(nil),
		(*Command_DataplaneStatus)(nil),
		(*Command_EventReport)(nil),
		(*Command_DataplaneSoftwareDetails)(nil),
		(*Command_DataplaneUpdate)(nil),
	}
}

func _Command_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Command)
	// data
	switch x := m.Data.(type) {
	case *Command_CmdStatus:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CmdStatus); err != nil {
			return err
		}
	case *Command_NginxConfig:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NginxConfig); err != nil {
			return err
		}
	case *Command_NginxConfigResponse:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NginxConfigResponse); err != nil {
			return err
		}
	case *Command_AgentConnectRequest:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AgentConnectRequest); err != nil {
			return err
		}
	case *Command_AgentConnectResponse:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AgentConnectResponse); err != nil {
			return err
		}
	case *Command_AgentConfigRequest:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AgentConfigRequest); err != nil {
			return err
		}
	case *Command_AgentConfig:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AgentConfig); err != nil {
			return err
		}
	case *Command_DataplaneStatus:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataplaneStatus); err != nil {
			return err
		}
	case *Command_EventReport:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EventReport); err != nil {
			return err
		}
	case *Command_DataplaneSoftwareDetails:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataplaneSoftwareDetails); err != nil {
			return err
		}
	case *Command_DataplaneUpdate:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataplaneUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Command.Data has unexpected type %T", x)
	}
	return nil
}

func _Command_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Command)
	switch tag {
	case 3: // data.cmd_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandStatusResponse)
		err := b.DecodeMessage(msg)
		m.Data = &Command_CmdStatus{msg}
		return true, err
	case 4: // data.nginx_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NginxConfig)
		err := b.DecodeMessage(msg)
		m.Data = &Command_NginxConfig{msg}
		return true, err
	case 5: // data.nginx_config_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NginxConfigResponse)
		err := b.DecodeMessage(msg)
		m.Data = &Command_NginxConfigResponse{msg}
		return true, err
	case 6: // data.agent_connect_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AgentConnectRequest)
		err := b.DecodeMessage(msg)
		m.Data = &Command_AgentConnectRequest{msg}
		return true, err
	case 7: // data.agent_connect_response
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AgentConnectResponse)
		err := b.DecodeMessage(msg)
		m.Data = &Command_AgentConnectResponse{msg}
		return true, err
	case 8: // data.agent_config_request
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AgentConfigRequest)
		err := b.DecodeMessage(msg)
		m.Data = &Command_AgentConfigRequest{msg}
		return true, err
	case 9: // data.agent_config
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AgentConfig)
		err := b.DecodeMessage(msg)
		m.Data = &Command_AgentConfig{msg}
		return true, err
	case 11: // data.dataplane_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataplaneStatus)
		err := b.DecodeMessage(msg)
		m.Data = &Command_DataplaneStatus{msg}
		return true, err
	case 12: // data.event_report
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(events.EventReport)
		err := b.DecodeMessage(msg)
		m.Data = &Command_EventReport{msg}
		return true, err
	case 13: // data.dataplane_software_details
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataplaneSoftwareDetails)
		err := b.DecodeMessage(msg)
		m.Data = &Command_DataplaneSoftwareDetails{msg}
		return true, err
	case 14: // data.dataplane_update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataplaneUpdate)
		err := b.DecodeMessage(msg)
		m.Data = &Command_DataplaneUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Command_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Command)
	// data
	switch x := m.Data.(type) {
	case *Command_CmdStatus:
		s := proto.Size(x.CmdStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_NginxConfig:
		s := proto.Size(x.NginxConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_NginxConfigResponse:
		s := proto.Size(x.NginxConfigResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_AgentConnectRequest:
		s := proto.Size(x.AgentConnectRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_AgentConnectResponse:
		s := proto.Size(x.AgentConnectResponse)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_AgentConfigRequest:
		s := proto.Size(x.AgentConfigRequest)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_AgentConfig:
		s := proto.Size(x.AgentConfig)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_DataplaneStatus:
		s := proto.Size(x.DataplaneStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_EventReport:
		s := proto.Size(x.EventReport)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_DataplaneSoftwareDetails:
		s := proto.Size(x.DataplaneSoftwareDetails)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Command_DataplaneUpdate:
		s := proto.Size(x.DataplaneUpdate)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a command status response
type CommandStatusResponse struct {
	// Command status
	Status CommandStatusResponse_CommandStatus `protobuf:"varint,1,opt,name=status,proto3,enum=f5.nginx.agent.sdk.CommandStatusResponse_CommandStatus" json:"status"`
	// Error code
	ErrorCode CommandStatusResponse_CommandErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=f5.nginx.agent.sdk.CommandStatusResponse_CommandErrorCode" json:"error_code"`
	// Provides a user friendly message to describe the response
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message"`
	// Provides an error message of why the command failed
	Error                string   `protobuf:"bytes,4,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandStatusResponse) Reset()         { *m = CommandStatusResponse{} }
func (m *CommandStatusResponse) String() string { return proto.CompactTextString(m) }
func (*CommandStatusResponse) ProtoMessage()    {}
func (*CommandStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{1}
}
func (m *CommandStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStatusResponse.Merge(m, src)
}
func (m *CommandStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommandStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStatusResponse proto.InternalMessageInfo

func (m *CommandStatusResponse) GetStatus() CommandStatusResponse_CommandStatus {
	if m != nil {
		return m.Status
	}
	return CommandStatusResponse_CMD_UNKNOWN
}

func (m *CommandStatusResponse) GetErrorCode() CommandStatusResponse_CommandErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return CommandStatusResponse_ERR_OK
}

func (m *CommandStatusResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CommandStatusResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Represents a dataplane status, which is used by the agent to periodically report the status of NGINX, agent activities and other dataplane software activities.
type DataplaneStatus struct {
	// System ID
	SystemId string `protobuf:"bytes,1,opt,name=system_id,json=systemId,proto3" json:"system_id"`
	// List of NGINX details. This field will be moving to DataplaneSoftwareDetails in a future release.
	Details []*NginxDetails `protobuf:"bytes,2,rep,name=details,proto3" json:"details"`
	// Host information
	Host *HostInfo `protobuf:"bytes,3,opt,name=host,proto3" json:"host"`
	// List of NGINX health information. This field will be moving to DataplaneSoftwareHealth in a future release.
	Healths []*NginxHealth `protobuf:"bytes,5,rep,name=healths,proto3" json:"healths"`
	// List of software details. This includes details about NGINX and any other software installed in the system that the agent is interested in.
	DataplaneSoftwareDetails []*DataplaneSoftwareDetails `protobuf:"bytes,6,rep,name=dataplane_software_details,json=dataplaneSoftwareDetails,proto3" json:"dataplane_software_details"`
	// List of software health statues. This includes the health of NGINX and any other software installed in the system that the agent is interested in.
	DataplaneSoftwareHealths []*DataplaneSoftwareHealth `protobuf:"bytes,7,rep,name=dataplane_software_healths,json=dataplaneSoftwareHealths,proto3" json:"dataplane_software_healths"`
	// List of activity statuses. Reports on the status of activities that the agent is currently executing.
	AgentActivityStatus  []*AgentActivityStatus `protobuf:"bytes,8,rep,name=agent_activity_status,json=agentActivityStatus,proto3" json:"agent_activity_status"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DataplaneStatus) Reset()         { *m = DataplaneStatus{} }
func (m *DataplaneStatus) String() string { return proto.CompactTextString(m) }
func (*DataplaneStatus) ProtoMessage()    {}
func (*DataplaneStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{2}
}
func (m *DataplaneStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataplaneStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataplaneStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataplaneStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataplaneStatus.Merge(m, src)
}
func (m *DataplaneStatus) XXX_Size() int {
	return m.Size()
}
func (m *DataplaneStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DataplaneStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DataplaneStatus proto.InternalMessageInfo

func (m *DataplaneStatus) GetSystemId() string {
	if m != nil {
		return m.SystemId
	}
	return ""
}

func (m *DataplaneStatus) GetDetails() []*NginxDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *DataplaneStatus) GetHost() *HostInfo {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *DataplaneStatus) GetHealths() []*NginxHealth {
	if m != nil {
		return m.Healths
	}
	return nil
}

func (m *DataplaneStatus) GetDataplaneSoftwareDetails() []*DataplaneSoftwareDetails {
	if m != nil {
		return m.DataplaneSoftwareDetails
	}
	return nil
}

func (m *DataplaneStatus) GetDataplaneSoftwareHealths() []*DataplaneSoftwareHealth {
	if m != nil {
		return m.DataplaneSoftwareHealths
	}
	return nil
}

func (m *DataplaneStatus) GetAgentActivityStatus() []*AgentActivityStatus {
	if m != nil {
		return m.AgentActivityStatus
	}
	return nil
}

// Represent an agent activity status
type AgentActivityStatus struct {
	// Types that are valid to be assigned to Status:
	//	*AgentActivityStatus_NginxConfigStatus
	Status               isAgentActivityStatus_Status `protobuf_oneof:"Status"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *AgentActivityStatus) Reset()         { *m = AgentActivityStatus{} }
func (m *AgentActivityStatus) String() string { return proto.CompactTextString(m) }
func (*AgentActivityStatus) ProtoMessage()    {}
func (*AgentActivityStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{3}
}
func (m *AgentActivityStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AgentActivityStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AgentActivityStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AgentActivityStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AgentActivityStatus.Merge(m, src)
}
func (m *AgentActivityStatus) XXX_Size() int {
	return m.Size()
}
func (m *AgentActivityStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_AgentActivityStatus.DiscardUnknown(m)
}

var xxx_messageInfo_AgentActivityStatus proto.InternalMessageInfo

type isAgentActivityStatus_Status interface {
	isAgentActivityStatus_Status()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AgentActivityStatus_NginxConfigStatus struct {
	NginxConfigStatus *NginxConfigStatus `protobuf:"bytes,1,opt,name=nginx_config_status,json=nginxConfigStatus,proto3,oneof"`
}

func (*AgentActivityStatus_NginxConfigStatus) isAgentActivityStatus_Status() {}

func (m *AgentActivityStatus) GetStatus() isAgentActivityStatus_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *AgentActivityStatus) GetNginxConfigStatus() *NginxConfigStatus {
	if x, ok := m.GetStatus().(*AgentActivityStatus_NginxConfigStatus); ok {
		return x.NginxConfigStatus
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AgentActivityStatus) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AgentActivityStatus_OneofMarshaler, _AgentActivityStatus_OneofUnmarshaler, _AgentActivityStatus_OneofSizer, []interface{}{
		(*AgentActivityStatus_NginxConfigStatus)(nil),
	}
}

func _AgentActivityStatus_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AgentActivityStatus)
	// Status
	switch x := m.Status.(type) {
	case *AgentActivityStatus_NginxConfigStatus:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NginxConfigStatus); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AgentActivityStatus.Status has unexpected type %T", x)
	}
	return nil
}

func _AgentActivityStatus_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AgentActivityStatus)
	switch tag {
	case 1: // Status.nginx_config_status
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NginxConfigStatus)
		err := b.DecodeMessage(msg)
		m.Status = &AgentActivityStatus_NginxConfigStatus{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AgentActivityStatus_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AgentActivityStatus)
	// Status
	switch x := m.Status.(type) {
	case *AgentActivityStatus_NginxConfigStatus:
		s := proto.Size(x.NginxConfigStatus)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a NGINX configuration status
type NginxConfigStatus struct {
	// CorrelationID is an ID used by the producer of the message to track the flow of events
	CorrelationId string `protobuf:"bytes,1,opt,name=correlation_id,json=correlationId,proto3" json:"correlation_id"`
	// Provides a status for the NGINX configuration
	Status NginxConfigStatus_Status `protobuf:"varint,2,opt,name=status,proto3,enum=f5.nginx.agent.sdk.NginxConfigStatus_Status" json:"status"`
	// Provides a user friendly message to describe the current state of the NGINX configuration.
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message"`
	// NGINX ID
	NginxId              string   `protobuf:"bytes,4,opt,name=nginx_id,json=nginxId,proto3" json:"nginx_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NginxConfigStatus) Reset()         { *m = NginxConfigStatus{} }
func (m *NginxConfigStatus) String() string { return proto.CompactTextString(m) }
func (*NginxConfigStatus) ProtoMessage()    {}
func (*NginxConfigStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{4}
}
func (m *NginxConfigStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NginxConfigStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NginxConfigStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NginxConfigStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NginxConfigStatus.Merge(m, src)
}
func (m *NginxConfigStatus) XXX_Size() int {
	return m.Size()
}
func (m *NginxConfigStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_NginxConfigStatus.DiscardUnknown(m)
}

var xxx_messageInfo_NginxConfigStatus proto.InternalMessageInfo

func (m *NginxConfigStatus) GetCorrelationId() string {
	if m != nil {
		return m.CorrelationId
	}
	return ""
}

func (m *NginxConfigStatus) GetStatus() NginxConfigStatus_Status {
	if m != nil {
		return m.Status
	}
	return NginxConfigStatus_PENDING
}

func (m *NginxConfigStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *NginxConfigStatus) GetNginxId() string {
	if m != nil {
		return m.NginxId
	}
	return ""
}

// Represents a dataplane software health
type DataplaneSoftwareHealth struct {
	// Types that are valid to be assigned to Health:
	//	*DataplaneSoftwareHealth_NginxHealth
	//	*DataplaneSoftwareHealth_AppProtectWafHealth
	Health               isDataplaneSoftwareHealth_Health `protobuf_oneof:"health"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DataplaneSoftwareHealth) Reset()         { *m = DataplaneSoftwareHealth{} }
func (m *DataplaneSoftwareHealth) String() string { return proto.CompactTextString(m) }
func (*DataplaneSoftwareHealth) ProtoMessage()    {}
func (*DataplaneSoftwareHealth) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{5}
}
func (m *DataplaneSoftwareHealth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataplaneSoftwareHealth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataplaneSoftwareHealth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataplaneSoftwareHealth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataplaneSoftwareHealth.Merge(m, src)
}
func (m *DataplaneSoftwareHealth) XXX_Size() int {
	return m.Size()
}
func (m *DataplaneSoftwareHealth) XXX_DiscardUnknown() {
	xxx_messageInfo_DataplaneSoftwareHealth.DiscardUnknown(m)
}

var xxx_messageInfo_DataplaneSoftwareHealth proto.InternalMessageInfo

type isDataplaneSoftwareHealth_Health interface {
	isDataplaneSoftwareHealth_Health()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DataplaneSoftwareHealth_NginxHealth struct {
	NginxHealth *NginxHealth `protobuf:"bytes,1,opt,name=nginx_health,json=nginxHealth,proto3,oneof"`
}
type DataplaneSoftwareHealth_AppProtectWafHealth struct {
	AppProtectWafHealth *AppProtectWAFHealth `protobuf:"bytes,2,opt,name=app_protect_waf_health,json=appProtectWafHealth,proto3,oneof"`
}

func (*DataplaneSoftwareHealth_NginxHealth) isDataplaneSoftwareHealth_Health()         {}
func (*DataplaneSoftwareHealth_AppProtectWafHealth) isDataplaneSoftwareHealth_Health() {}

func (m *DataplaneSoftwareHealth) GetHealth() isDataplaneSoftwareHealth_Health {
	if m != nil {
		return m.Health
	}
	return nil
}

func (m *DataplaneSoftwareHealth) GetNginxHealth() *NginxHealth {
	if x, ok := m.GetHealth().(*DataplaneSoftwareHealth_NginxHealth); ok {
		return x.NginxHealth
	}
	return nil
}

func (m *DataplaneSoftwareHealth) GetAppProtectWafHealth() *AppProtectWAFHealth {
	if x, ok := m.GetHealth().(*DataplaneSoftwareHealth_AppProtectWafHealth); ok {
		return x.AppProtectWafHealth
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataplaneSoftwareHealth) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataplaneSoftwareHealth_OneofMarshaler, _DataplaneSoftwareHealth_OneofUnmarshaler, _DataplaneSoftwareHealth_OneofSizer, []interface{}{
		(*DataplaneSoftwareHealth_NginxHealth)(nil),
		(*DataplaneSoftwareHealth_AppProtectWafHealth)(nil),
	}
}

func _DataplaneSoftwareHealth_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataplaneSoftwareHealth)
	// health
	switch x := m.Health.(type) {
	case *DataplaneSoftwareHealth_NginxHealth:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NginxHealth); err != nil {
			return err
		}
	case *DataplaneSoftwareHealth_AppProtectWafHealth:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AppProtectWafHealth); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DataplaneSoftwareHealth.Health has unexpected type %T", x)
	}
	return nil
}

func _DataplaneSoftwareHealth_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataplaneSoftwareHealth)
	switch tag {
	case 1: // health.nginx_health
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NginxHealth)
		err := b.DecodeMessage(msg)
		m.Health = &DataplaneSoftwareHealth_NginxHealth{msg}
		return true, err
	case 2: // health.app_protect_waf_health
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AppProtectWAFHealth)
		err := b.DecodeMessage(msg)
		m.Health = &DataplaneSoftwareHealth_AppProtectWafHealth{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DataplaneSoftwareHealth_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataplaneSoftwareHealth)
	// health
	switch x := m.Health.(type) {
	case *DataplaneSoftwareHealth_NginxHealth:
		s := proto.Size(x.NginxHealth)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataplaneSoftwareHealth_AppProtectWafHealth:
		s := proto.Size(x.AppProtectWafHealth)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a dataplane update
type DataplaneUpdate struct {
	// Host information
	Host *HostInfo `protobuf:"bytes,1,opt,name=host,proto3" json:"host"`
	// List of software details. This includes details about NGINX and any other software installed in the system that the agent is interested in.
	DataplaneSoftwareDetails []*DataplaneSoftwareDetails `protobuf:"bytes,2,rep,name=dataplane_software_details,json=dataplaneSoftwareDetails,proto3" json:"dataplane_software_details"`
	XXX_NoUnkeyedLiteral     struct{}                    `json:"-"`
	XXX_unrecognized         []byte                      `json:"-"`
	XXX_sizecache            int32                       `json:"-"`
}

func (m *DataplaneUpdate) Reset()         { *m = DataplaneUpdate{} }
func (m *DataplaneUpdate) String() string { return proto.CompactTextString(m) }
func (*DataplaneUpdate) ProtoMessage()    {}
func (*DataplaneUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{6}
}
func (m *DataplaneUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataplaneUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataplaneUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataplaneUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataplaneUpdate.Merge(m, src)
}
func (m *DataplaneUpdate) XXX_Size() int {
	return m.Size()
}
func (m *DataplaneUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_DataplaneUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_DataplaneUpdate proto.InternalMessageInfo

func (m *DataplaneUpdate) GetHost() *HostInfo {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *DataplaneUpdate) GetDataplaneSoftwareDetails() []*DataplaneSoftwareDetails {
	if m != nil {
		return m.DataplaneSoftwareDetails
	}
	return nil
}

// Represents a download request
type DownloadRequest struct {
	// Metadata information
	Meta                 *Metadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{7}
}
func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(m, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

// Represents a NGINX config response
type NginxConfigResponse struct {
	// Command status
	Status *CommandStatusResponse `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	// NGINX config action
	Action NginxConfigAction `protobuf:"varint,2,opt,name=action,proto3,enum=f5.nginx.agent.sdk.NginxConfigAction" json:"action"`
	// NGINX config description
	ConfigData           *ConfigDescriptor `protobuf:"bytes,3,opt,name=config_data,json=configData,proto3" json:"config_data"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *NginxConfigResponse) Reset()         { *m = NginxConfigResponse{} }
func (m *NginxConfigResponse) String() string { return proto.CompactTextString(m) }
func (*NginxConfigResponse) ProtoMessage()    {}
func (*NginxConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{8}
}
func (m *NginxConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NginxConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NginxConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NginxConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NginxConfigResponse.Merge(m, src)
}
func (m *NginxConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *NginxConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NginxConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NginxConfigResponse proto.InternalMessageInfo

func (m *NginxConfigResponse) GetStatus() *CommandStatusResponse {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *NginxConfigResponse) GetAction() NginxConfigAction {
	if m != nil {
		return m.Action
	}
	return NginxConfigAction_UNKNOWN
}

func (m *NginxConfigResponse) GetConfigData() *ConfigDescriptor {
	if m != nil {
		return m.ConfigData
	}
	return nil
}

// Represents an upload status
type UploadStatus struct {
	// Metadata information
	Meta *Metadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta"`
	// Transfer status
	Status UploadStatus_TransferStatus `protobuf:"varint,2,opt,name=status,proto3,enum=f5.nginx.agent.sdk.UploadStatus_TransferStatus" json:"status"`
	// Provides an error message of why the upload failed
	Reason               string   `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadStatus) Reset()         { *m = UploadStatus{} }
func (m *UploadStatus) String() string { return proto.CompactTextString(m) }
func (*UploadStatus) ProtoMessage()    {}
func (*UploadStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{9}
}
func (m *UploadStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadStatus.Merge(m, src)
}
func (m *UploadStatus) XXX_Size() int {
	return m.Size()
}
func (m *UploadStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UploadStatus proto.InternalMessageInfo

func (m *UploadStatus) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *UploadStatus) GetStatus() UploadStatus_TransferStatus {
	if m != nil {
		return m.Status
	}
	return UploadStatus_UNKNOWN
}

func (m *UploadStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Represents a data chunck
type DataChunk struct {
	// Types that are valid to be assigned to Chunk:
	//	*DataChunk_Header
	//	*DataChunk_Data
	Chunk                isDataChunk_Chunk `protobuf_oneof:"chunk"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *DataChunk) Reset()         { *m = DataChunk{} }
func (m *DataChunk) String() string { return proto.CompactTextString(m) }
func (*DataChunk) ProtoMessage()    {}
func (*DataChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{10}
}
func (m *DataChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataChunk.Merge(m, src)
}
func (m *DataChunk) XXX_Size() int {
	return m.Size()
}
func (m *DataChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_DataChunk.DiscardUnknown(m)
}

var xxx_messageInfo_DataChunk proto.InternalMessageInfo

type isDataChunk_Chunk interface {
	isDataChunk_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type DataChunk_Header struct {
	Header *ChunkedResourceHeader `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}
type DataChunk_Data struct {
	Data *ChunkedResourceChunk `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*DataChunk_Header) isDataChunk_Chunk() {}
func (*DataChunk_Data) isDataChunk_Chunk()   {}

func (m *DataChunk) GetChunk() isDataChunk_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *DataChunk) GetHeader() *ChunkedResourceHeader {
	if x, ok := m.GetChunk().(*DataChunk_Header); ok {
		return x.Header
	}
	return nil
}

func (m *DataChunk) GetData() *ChunkedResourceChunk {
	if x, ok := m.GetChunk().(*DataChunk_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataChunk_OneofMarshaler, _DataChunk_OneofUnmarshaler, _DataChunk_OneofSizer, []interface{}{
		(*DataChunk_Header)(nil),
		(*DataChunk_Data)(nil),
	}
}

func _DataChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataChunk)
	// chunk
	switch x := m.Chunk.(type) {
	case *DataChunk_Header:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Header); err != nil {
			return err
		}
	case *DataChunk_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Data); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DataChunk.Chunk has unexpected type %T", x)
	}
	return nil
}

func _DataChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataChunk)
	switch tag {
	case 1: // chunk.header
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChunkedResourceHeader)
		err := b.DecodeMessage(msg)
		m.Chunk = &DataChunk_Header{msg}
		return true, err
	case 2: // chunk.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ChunkedResourceChunk)
		err := b.DecodeMessage(msg)
		m.Chunk = &DataChunk_Data{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DataChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataChunk)
	// chunk
	switch x := m.Chunk.(type) {
	case *DataChunk_Header:
		s := proto.Size(x.Header)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DataChunk_Data:
		s := proto.Size(x.Data)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Represents a chunked resource Header
type ChunkedResourceHeader struct {
	// Metadata information
	Meta *Metadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta"`
	// Number of chunks expected in the transfer
	Chunks int32 `protobuf:"varint,2,opt,name=chunks,proto3" json:"chunks"`
	// Chunk checksum
	Checksum string `protobuf:"bytes,3,opt,name=checksum,proto3" json:"checksum"`
	// Chunk size
	ChunkSize            int32    `protobuf:"varint,4,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChunkedResourceHeader) Reset()         { *m = ChunkedResourceHeader{} }
func (m *ChunkedResourceHeader) String() string { return proto.CompactTextString(m) }
func (*ChunkedResourceHeader) ProtoMessage()    {}
func (*ChunkedResourceHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{11}
}
func (m *ChunkedResourceHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChunkedResourceHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChunkedResourceHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChunkedResourceHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChunkedResourceHeader.Merge(m, src)
}
func (m *ChunkedResourceHeader) XXX_Size() int {
	return m.Size()
}
func (m *ChunkedResourceHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ChunkedResourceHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ChunkedResourceHeader proto.InternalMessageInfo

func (m *ChunkedResourceHeader) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ChunkedResourceHeader) GetChunks() int32 {
	if m != nil {
		return m.Chunks
	}
	return 0
}

func (m *ChunkedResourceHeader) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *ChunkedResourceHeader) GetChunkSize() int32 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

// Represents a chunked resource chunk
type ChunkedResourceChunk struct {
	// Metadata information
	Meta *Metadata `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta"`
	// Chunk ID
	ChunkId int32 `protobuf:"varint,2,opt,name=chunk_id,json=chunkId,proto3" json:"chunk_id"`
	// Chunk data
	Data                 []byte   `protobuf:"bytes,3,opt,name=data,proto3" json:"data"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChunkedResourceChunk) Reset()         { *m = ChunkedResourceChunk{} }
func (m *ChunkedResourceChunk) String() string { return proto.CompactTextString(m) }
func (*ChunkedResourceChunk) ProtoMessage()    {}
func (*ChunkedResourceChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{12}
}
func (m *ChunkedResourceChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChunkedResourceChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChunkedResourceChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChunkedResourceChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChunkedResourceChunk.Merge(m, src)
}
func (m *ChunkedResourceChunk) XXX_Size() int {
	return m.Size()
}
func (m *ChunkedResourceChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_ChunkedResourceChunk.DiscardUnknown(m)
}

var xxx_messageInfo_ChunkedResourceChunk proto.InternalMessageInfo

func (m *ChunkedResourceChunk) GetMeta() *Metadata {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ChunkedResourceChunk) GetChunkId() int32 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *ChunkedResourceChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("f5.nginx.agent.sdk.Command_CommandType", Command_CommandType_name, Command_CommandType_value)
	proto.RegisterEnum("f5.nginx.agent.sdk.CommandStatusResponse_CommandStatus", CommandStatusResponse_CommandStatus_name, CommandStatusResponse_CommandStatus_value)
	proto.RegisterEnum("f5.nginx.agent.sdk.CommandStatusResponse_CommandErrorCode", CommandStatusResponse_CommandErrorCode_name, CommandStatusResponse_CommandErrorCode_value)
	proto.RegisterEnum("f5.nginx.agent.sdk.NginxConfigStatus_Status", NginxConfigStatus_Status_name, NginxConfigStatus_Status_value)
	proto.RegisterEnum("f5.nginx.agent.sdk.UploadStatus_TransferStatus", UploadStatus_TransferStatus_name, UploadStatus_TransferStatus_value)
	proto.RegisterType((*Command)(nil), "f5.nginx.agent.sdk.Command")
	proto.RegisterType((*CommandStatusResponse)(nil), "f5.nginx.agent.sdk.CommandStatusResponse")
	proto.RegisterType((*DataplaneStatus)(nil), "f5.nginx.agent.sdk.DataplaneStatus")
	proto.RegisterType((*AgentActivityStatus)(nil), "f5.nginx.agent.sdk.AgentActivityStatus")
	proto.RegisterType((*NginxConfigStatus)(nil), "f5.nginx.agent.sdk.NginxConfigStatus")
	proto.RegisterType((*DataplaneSoftwareHealth)(nil), "f5.nginx.agent.sdk.DataplaneSoftwareHealth")
	proto.RegisterType((*DataplaneUpdate)(nil), "f5.nginx.agent.sdk.DataplaneUpdate")
	proto.RegisterType((*DownloadRequest)(nil), "f5.nginx.agent.sdk.DownloadRequest")
	proto.RegisterType((*NginxConfigResponse)(nil), "f5.nginx.agent.sdk.NginxConfigResponse")
	proto.RegisterType((*UploadStatus)(nil), "f5.nginx.agent.sdk.UploadStatus")
	proto.RegisterType((*DataChunk)(nil), "f5.nginx.agent.sdk.DataChunk")
	proto.RegisterType((*ChunkedResourceHeader)(nil), "f5.nginx.agent.sdk.ChunkedResourceHeader")
	proto.RegisterType((*ChunkedResourceChunk)(nil), "f5.nginx.agent.sdk.ChunkedResourceChunk")
}

func init() { proto.RegisterFile("command.proto", fileDescriptor_213c0bb044472049) }

var fileDescriptor_213c0bb044472049 = []byte{
	// 1534 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcb, 0x6e, 0xdb, 0x46,
	0x17, 0x26, 0x15, 0xeb, 0x76, 0x24, 0xdb, 0xca, 0xd8, 0x49, 0x14, 0x23, 0x30, 0x0d, 0xfe, 0x7f,
	0x6a, 0xa7, 0x4d, 0x25, 0xd4, 0x41, 0x11, 0x34, 0x59, 0x59, 0x96, 0x13, 0x0a, 0x89, 0x65, 0x63,
	0x12, 0x27, 0x40, 0x8a, 0x42, 0x60, 0xc4, 0x91, 0x4c, 0xd8, 0x22, 0x59, 0x92, 0x72, 0xe2, 0xa0,
	0xfb, 0xa2, 0x45, 0x37, 0x5d, 0x74, 0xd1, 0xf6, 0x21, 0xfa, 0x1a, 0x5d, 0x66, 0xdd, 0x05, 0x51,
	0x64, 0xc9, 0x07, 0x68, 0x17, 0xdd, 0x14, 0x73, 0xa1, 0x44, 0x49, 0x94, 0xec, 0xd4, 0x45, 0x37,
	0x9a, 0xe1, 0xf0, 0x3b, 0xdf, 0xb9, 0xcc, 0xcc, 0x37, 0x43, 0xc1, 0x7c, 0xdb, 0xee, 0xf5, 0x74,
	0xcb, 0xa8, 0x38, 0xae, 0xed, 0xdb, 0x08, 0x75, 0x3e, 0xad, 0x58, 0x5d, 0xd3, 0x7a, 0x5d, 0xd1,
	0xbb, 0xc4, 0xf2, 0x2b, 0x9e, 0x71, 0xb4, 0x52, 0xe0, 0x5d, 0x06, 0x58, 0x29, 0x52, 0xbc, 0x6d,
	0x0d, 0x9f, 0xac, 0x8e, 0xd9, 0x15, 0x4f, 0xd7, 0x0d, 0xa7, 0xe5, 0xd9, 0x1d, 0xff, 0x95, 0xee,
	0x92, 0x96, 0x41, 0x7c, 0xdd, 0x3c, 0xf6, 0xc4, 0x2b, 0x44, 0x4e, 0x88, 0xe5, 0x7b, 0x55, 0xd6,
	0x88, 0x31, 0xe8, 0xda, 0x5d, 0x3b, 0xea, 0x1f, 0xda, 0x5e, 0x34, 0x9e, 0xb7, 0x74, 0x47, 0x74,
	0x0b, 0x3c, 0x16, 0xf6, 0xa0, 0xfe, 0x05, 0x90, 0xdd, 0xe6, 0xd1, 0xa2, 0x7b, 0x30, 0xd7, 0x23,
	0xbe, 0x5e, 0x96, 0xd7, 0xe4, 0x8d, 0xc2, 0xe6, 0x8d, 0xca, 0x64, 0xd8, 0x95, 0x5d, 0xe2, 0xeb,
	0x86, 0xee, 0xeb, 0xb5, 0x5c, 0x18, 0x28, 0x0c, 0x8d, 0xd9, 0x2f, 0xda, 0x81, 0x39, 0xff, 0xd4,
	0x21, 0xe5, 0xd4, 0x9a, 0xbc, 0xb1, 0xb0, 0xb9, 0x9e, 0x64, 0x2b, 0xdc, 0x44, 0xed, 0xd3, 0x53,
	0x87, 0x70, 0x1a, 0x6a, 0x88, 0xd9, 0x2f, 0x7a, 0x01, 0xd0, 0xee, 0x19, 0x2d, 0xcf, 0xd7, 0xfd,
	0xbe, 0x57, 0xbe, 0xc4, 0x02, 0xb9, 0x35, 0x83, 0xec, 0x09, 0x03, 0x62, 0xe2, 0x39, 0xb6, 0xe5,
	0x91, 0xda, 0x42, 0x18, 0x28, 0x31, 0x02, 0x4d, 0xc2, 0xf9, 0x76, 0x4f, 0x80, 0xd0, 0x33, 0x28,
	0x32, 0x96, 0x16, 0xaf, 0x6f, 0x79, 0x8e, 0xb1, 0x2b, 0x49, 0xec, 0x4d, 0xfa, 0xbc, 0xcd, 0x60,
	0xb5, 0x52, 0x18, 0x28, 0x23, 0x86, 0x9a, 0x84, 0x79, 0x09, 0x39, 0x00, 0xbd, 0x86, 0x2b, 0xf1,
	0xd7, 0x2d, 0x57, 0x44, 0x53, 0x4e, 0x33, 0x07, 0xeb, 0x67, 0x38, 0x18, 0x04, 0x7f, 0x3d, 0x0c,
	0x94, 0x64, 0x26, 0x4d, 0xc2, 0x4b, 0xd6, 0xa4, 0x05, 0xf5, 0xcc, 0x28, 0x29, 0xde, 0x22, 0x6d,
	0xbf, 0xe5, 0x92, 0x2f, 0xfb, 0xc4, 0xf3, 0xcb, 0x99, 0xe9, 0x9e, 0xb7, 0x68, 0x6f, 0x9b, 0xe3,
	0x31, 0x87, 0x73, 0xcf, 0x89, 0x4c, 0xd4, 0xb3, 0x3e, 0x69, 0x81, 0xbe, 0x82, 0xab, 0xe3, 0x78,
	0x91, 0x74, 0x96, 0xb9, 0xde, 0x38, 0xdb, 0xb5, 0xc8, 0x7a, 0x25, 0x0c, 0x94, 0x29, 0x5c, 0x9a,
	0x84, 0x97, 0xf5, 0x04, 0x1b, 0xe4, 0xc3, 0xf2, 0xc0, 0x82, 0xd7, 0x89, 0xa7, 0x9d, 0x63, 0xbe,
	0x3f, 0x98, 0xe5, 0x9b, 0x95, 0x8f, 0x67, 0x5d, 0x0e, 0x03, 0x25, 0x91, 0x47, 0x93, 0x30, 0xd2,
	0x27, 0xf0, 0x74, 0xfd, 0xc4, 0xd1, 0xe5, 0xfc, 0xf4, 0xf5, 0x13, 0xf3, 0xc6, 0xd7, 0x4f, 0xdc,
	0x90, 0xae, 0x9f, 0x18, 0x3d, 0xea, 0x40, 0x89, 0x6e, 0x29, 0xe7, 0x58, 0xb7, 0x48, 0xb4, 0xf2,
	0x0b, 0x8c, 0xfb, 0x7f, 0x49, 0xdc, 0xf5, 0x08, 0xcb, 0x97, 0x75, 0x6d, 0x39, 0x0c, 0x94, 0x09,
	0x02, 0x4d, 0xc2, 0x8b, 0xc6, 0x28, 0x10, 0x7d, 0x01, 0x45, 0xa6, 0x14, 0x2d, 0x97, 0x38, 0xb6,
	0xeb, 0x97, 0x8b, 0xd3, 0xab, 0xc5, 0x85, 0xa5, 0xb2, 0x43, 0x1b, 0xcc, 0xd0, 0x3c, 0x8d, 0xb8,
	0x3d, 0x4d, 0x83, 0x0c, 0x01, 0xe8, 0x3b, 0x19, 0x56, 0x62, 0x61, 0x8c, 0x49, 0x56, 0x79, 0x9e,
	0x79, 0xbb, 0x3d, 0x3b, 0x23, 0x61, 0x54, 0xe7, 0x36, 0xb5, 0xd5, 0x30, 0x50, 0x66, 0x70, 0x6a,
	0x12, 0x2e, 0x1b, 0x53, 0x6c, 0x47, 0xab, 0xda, 0x77, 0x0c, 0xdd, 0x27, 0xe5, 0x85, 0x73, 0x54,
	0xf5, 0x80, 0x41, 0xc7, 0xab, 0xca, 0x09, 0x46, 0xaa, 0xca, 0x81, 0xea, 0x1d, 0x28, 0xc4, 0x04,
	0x0d, 0x01, 0x64, 0x9a, 0x7b, 0x78, 0x77, 0xeb, 0x71, 0x49, 0x42, 0x45, 0xc8, 0xd5, 0xf7, 0x9e,
	0x37, 0x1f, 0xef, 0x6d, 0xd5, 0x4b, 0x32, 0x7d, 0x73, 0xb0, 0xcf, 0xfa, 0xa9, 0x5a, 0x06, 0xe6,
	0x28, 0x8f, 0xfa, 0xc3, 0x25, 0xb8, 0x92, 0xa8, 0x64, 0xe8, 0x73, 0xc8, 0x88, 0xa5, 0x20, 0x33,
	0x45, 0xbd, 0x7b, 0x6e, 0x11, 0x1c, 0x1d, 0xad, 0x41, 0x18, 0x28, 0x82, 0x0a, 0x8b, 0x16, 0x99,
	0x00, 0xc4, 0x75, 0x6d, 0xb7, 0xd5, 0xb6, 0x8d, 0x48, 0xb2, 0xef, 0xbd, 0xb7, 0x83, 0x1d, 0x4a,
	0xb1, 0x6d, 0x1b, 0x42, 0x76, 0x87, 0x8c, 0x38, 0x4f, 0xa2, 0x57, 0xe8, 0x26, 0x64, 0x7b, 0xc4,
	0xf3, 0xf4, 0x2e, 0x61, 0x6a, 0x9e, 0xaf, 0x15, 0xc2, 0x40, 0x89, 0x86, 0x70, 0xd4, 0x41, 0x0a,
	0xa4, 0x99, 0x0d, 0x13, 0xe5, 0x7c, 0x2d, 0x1f, 0x06, 0x0a, 0x1f, 0xc0, 0xbc, 0x51, 0xef, 0xc3,
	0xfc, 0x48, 0x30, 0x68, 0x11, 0x0a, 0xdb, 0xbb, 0xf5, 0xd6, 0x41, 0xf3, 0x51, 0x73, 0xef, 0x79,
	0xb3, 0x24, 0xd1, 0xfa, 0xd2, 0x81, 0xbd, 0x47, 0x25, 0x19, 0xcd, 0x43, 0x9e, 0xf6, 0x77, 0x30,
	0xde, 0xc3, 0xa5, 0x94, 0x5a, 0x85, 0xd2, 0x78, 0xcc, 0x14, 0xbe, 0x83, 0x31, 0x85, 0x4b, 0x94,
	0x8b, 0xf6, 0x23, 0x2e, 0x59, 0xfd, 0x39, 0x0d, 0x8b, 0x63, 0xfb, 0x0c, 0x7d, 0x08, 0x79, 0xef,
	0xd4, 0xf3, 0x49, 0xaf, 0x65, 0x1a, 0x6c, 0x52, 0xf2, 0xb5, 0xf9, 0x30, 0x50, 0x86, 0x83, 0x38,
	0xc7, 0xbb, 0x0d, 0x03, 0x3d, 0x84, 0x6c, 0xb4, 0xee, 0x53, 0x6b, 0x97, 0x36, 0x0a, 0x9b, 0x6b,
	0x53, 0x0f, 0x81, 0x68, 0xad, 0xb3, 0xba, 0x08, 0x23, 0x1c, 0x75, 0xe8, 0x91, 0x4c, 0x0f, 0x71,
	0x71, 0x12, 0x26, 0x1e, 0xc9, 0x9a, 0xed, 0xf9, 0x0d, 0xab, 0x63, 0xf3, 0xb3, 0x94, 0xa2, 0x31,
	0xfb, 0x45, 0x0f, 0x20, 0x7b, 0x48, 0xf4, 0x63, 0xff, 0xd0, 0x2b, 0xa7, 0x59, 0x10, 0xd3, 0x8f,
	0x3a, 0x8d, 0xe1, 0x78, 0x0c, 0xc2, 0x06, 0x47, 0x1d, 0xf4, 0xed, 0xec, 0x8d, 0x9d, 0x61, 0xdc,
	0xff, 0xea, 0xc6, 0x9e, 0xb1, 0xad, 0xbf, 0x49, 0x0e, 0x26, 0x4a, 0x34, 0xcb, 0x82, 0xf9, 0xe8,
	0x5c, 0xc1, 0x88, 0xa4, 0xa7, 0xc5, 0x12, 0xd5, 0x61, 0x32, 0x16, 0x4d, 0x14, 0xe6, 0x24, 0x3a,
	0x7e, 0xf5, 0xb6, 0x6f, 0x9e, 0x98, 0xfe, 0x69, 0xa4, 0xde, 0x39, 0x16, 0xc5, 0xf4, 0xe3, 0x77,
	0x4b, 0xe0, 0xc5, 0x16, 0x8d, 0x1d, 0xbf, 0x63, 0x4c, 0xe2, 0xf0, 0x1d, 0xc5, 0xab, 0xdf, 0xcb,
	0xb0, 0x94, 0xc0, 0x83, 0x1c, 0x58, 0x1a, 0xb9, 0x3e, 0xc4, 0x04, 0xa4, 0xb0, 0x79, 0xf3, 0x8c,
	0x6b, 0x88, 0x88, 0xe5, 0x5a, 0x18, 0x28, 0x49, 0x2c, 0x9a, 0x84, 0x2f, 0x5b, 0x13, 0xe8, 0x1c,
	0x64, 0x44, 0x4c, 0x3f, 0xa5, 0xe0, 0xf2, 0x04, 0x1b, 0xfa, 0x0c, 0x16, 0xda, 0xb6, 0xeb, 0x92,
	0x63, 0xdd, 0x37, 0x6d, 0x6b, 0xb8, 0x71, 0x50, 0x18, 0x28, 0x63, 0x6f, 0xf0, 0x7c, 0xec, 0xb9,
	0x61, 0xa0, 0xfd, 0x81, 0x00, 0x72, 0x7d, 0xba, 0x7d, 0xae, 0xf8, 0x2b, 0x33, 0x54, 0xef, 0x9c,
	0x52, 0xb4, 0x0e, 0x39, 0x9e, 0xbf, 0x69, 0x08, 0x35, 0x2a, 0x86, 0x81, 0x32, 0x18, 0xc3, 0x59,
	0xd6, 0x6b, 0x18, 0xea, 0x46, 0x94, 0x3c, 0x2a, 0x40, 0x76, 0x7f, 0xa7, 0x59, 0x6f, 0x34, 0x1f,
	0x96, 0x24, 0x94, 0x81, 0x14, 0xd3, 0xa0, 0x3c, 0xa4, 0x23, 0xfd, 0xf9, 0x53, 0x86, 0x6b, 0x53,
	0x96, 0xdf, 0xf0, 0x56, 0xca, 0xd7, 0x9b, 0x98, 0xad, 0x33, 0xb7, 0x6a, 0xec, 0x56, 0xca, 0x0d,
	0x07, 0xb7, 0x52, 0xc1, 0xfb, 0x06, 0xae, 0xea, 0x8e, 0xd3, 0xa2, 0xb7, 0x7c, 0x7a, 0xa7, 0x7a,
	0xa5, 0x77, 0x22, 0x0f, 0xa9, 0x19, 0x97, 0x43, 0xc7, 0xd9, 0xe7, 0x06, 0xcf, 0xb7, 0x1e, 0x08,
	0x4f, 0xfc, 0x82, 0x96, 0x48, 0xc5, 0x6e, 0x87, 0x43, 0x13, 0xbd, 0x23, 0x4c, 0x72, 0x90, 0xe1,
	0x00, 0xf5, 0x37, 0x39, 0x26, 0xa4, 0xfc, 0xc4, 0x1c, 0x68, 0x9a, 0xfc, 0x0f, 0x34, 0xed, 0x0c,
	0x2d, 0x4a, 0xfd, 0x97, 0x5a, 0xa4, 0xee, 0xc2, 0x62, 0xdd, 0x7e, 0x65, 0x1d, 0xdb, 0xba, 0x11,
	0xdd, 0x11, 0x2f, 0xf0, 0x09, 0xa5, 0x7e, 0x9d, 0x82, 0xa5, 0x84, 0xef, 0x02, 0xb4, 0x3b, 0x72,
	0x15, 0x78, 0xaf, 0xef, 0xa1, 0xa4, 0x6d, 0xd0, 0x80, 0x0c, 0x55, 0x19, 0xdb, 0x12, 0x1b, 0xeb,
	0x2c, 0x61, 0xd8, 0x62, 0x60, 0x4e, 0xc5, 0x0d, 0xb1, 0x68, 0xd1, 0x33, 0x28, 0x08, 0x91, 0xa0,
	0x09, 0x89, 0x43, 0xea, 0xff, 0xc9, 0xe1, 0x51, 0x58, 0x9d, 0x78, 0x6d, 0xd7, 0x74, 0x7c, 0xdb,
	0xad, 0x2d, 0x86, 0x81, 0x12, 0x37, 0xc6, 0xc0, 0x1f, 0xe8, 0x34, 0xa9, 0x7f, 0xc8, 0x50, 0x3c,
	0x70, 0x68, 0x5d, 0xc5, 0x06, 0xbb, 0xc8, 0x97, 0xe9, 0x93, 0x31, 0x21, 0xa9, 0x26, 0x59, 0xc7,
	0xbd, 0x55, 0x9e, 0xba, 0xba, 0xe5, 0x75, 0x88, 0x3b, 0x43, 0x4b, 0x54, 0xc8, 0xb8, 0x44, 0xf7,
	0x6c, 0x4b, 0x48, 0x09, 0xc3, 0xf0, 0x11, 0x2c, 0x5a, 0xf5, 0x13, 0x58, 0x18, 0x65, 0xa2, 0x3a,
	0x31, 0xbc, 0xaf, 0x44, 0x3a, 0x01, 0x90, 0x79, 0xb0, 0xd5, 0x78, 0xbc, 0x53, 0x2f, 0xa5, 0xd4,
	0x5f, 0x64, 0xc8, 0xd3, 0x0a, 0x6c, 0x1f, 0xf6, 0xad, 0x23, 0xb4, 0xc7, 0xb6, 0x91, 0x41, 0xdc,
	0x99, 0x13, 0x4f, 0xa1, 0xc4, 0xc0, 0xc4, 0xb3, 0xfb, 0x6e, 0x9b, 0xaa, 0x8a, 0x41, 0x5c, 0x1e,
	0x0f, 0x37, 0xd6, 0x24, 0x2c, 0x7a, 0x48, 0xe3, 0xd7, 0x4e, 0xa1, 0x00, 0x1b, 0xe7, 0xa0, 0x63,
	0x8f, 0xbc, 0xa4, 0xd4, 0x52, 0x93, 0x30, 0x6b, 0x6b, 0x59, 0x48, 0xb7, 0xe9, 0x2b, 0xf5, 0xad,
	0x0c, 0x57, 0x12, 0x43, 0xb8, 0xd0, 0x9c, 0xa9, 0x90, 0x61, 0xf4, 0x7c, 0xce, 0xd2, 0x3c, 0x1d,
	0x3e, 0x82, 0x45, 0x8b, 0x36, 0x20, 0xd7, 0x3e, 0x24, 0xed, 0x23, 0xaf, 0xdf, 0x13, 0x93, 0xc0,
	0x74, 0x3a, 0x1a, 0xc3, 0x83, 0x1e, 0xfa, 0x18, 0x80, 0xd9, 0xb4, 0x3c, 0xf3, 0x0d, 0x61, 0x9a,
	0x9e, 0x16, 0xff, 0x14, 0x0c, 0x46, 0x71, 0x9e, 0xf5, 0x9f, 0x98, 0x6f, 0x88, 0xfa, 0xa3, 0x0c,
	0xcb, 0x49, 0x65, 0xb8, 0x50, 0x46, 0xeb, 0x34, 0x5a, 0xea, 0xcd, 0x34, 0x44, 0x4e, 0x22, 0x5a,
	0x3e, 0x86, 0xb3, 0xac, 0xd7, 0x30, 0xd0, 0x0d, 0x31, 0x47, 0x34, 0xa5, 0xe2, 0xb0, 0xf2, 0xa2,
	0xee, 0x77, 0x7f, 0x7d, 0xb7, 0x2a, 0xbf, 0x7d, 0xb7, 0x2a, 0xff, 0xfe, 0x6e, 0x55, 0x7e, 0x71,
	0xab, 0x6b, 0xfa, 0x87, 0xfd, 0x97, 0x95, 0xb6, 0xdd, 0xab, 0xb2, 0x48, 0xaa, 0x2c, 0x92, 0xaa,
	0x67, 0x1c, 0x55, 0x4f, 0x36, 0xab, 0xec, 0x1f, 0x9e, 0xfb, 0xec, 0xf7, 0x65, 0x86, 0x35, 0x77,
	0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x53, 0x4d, 0x33, 0x9b, 0x12, 0x00, 0x00,
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Meta.Size()))
		n1, err1 := m.Meta.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Type))
	}
	if m.Data != nil {
		nn2, err2 := m.Data.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += nn2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Command_CmdStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CmdStatus != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.CmdStatus.Size()))
		n3, err3 := m.CmdStatus.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}
func (m *Command_NginxConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NginxConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.NginxConfig.Size()))
		n4, err4 := m.NginxConfig.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}
func (m *Command_NginxConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NginxConfigResponse != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.NginxConfigResponse.Size()))
		n5, err5 := m.NginxConfigResponse.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}
func (m *Command_AgentConnectRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AgentConnectRequest != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.AgentConnectRequest.Size()))
		n6, err6 := m.AgentConnectRequest.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}
func (m *Command_AgentConnectResponse) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AgentConnectResponse != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.AgentConnectResponse.Size()))
		n7, err7 := m.AgentConnectResponse.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}
func (m *Command_AgentConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AgentConfigRequest != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.AgentConfigRequest.Size()))
		n8, err8 := m.AgentConfigRequest.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}
func (m *Command_AgentConfig) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AgentConfig != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.AgentConfig.Size()))
		n9, err9 := m.AgentConfig.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	return i, nil
}
func (m *Command_DataplaneStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataplaneStatus != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.DataplaneStatus.Size()))
		n10, err10 := m.DataplaneStatus.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}
func (m *Command_EventReport) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.EventReport != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.EventReport.Size()))
		n11, err11 := m.EventReport.MarshalTo(dAtA[i:])
		if err11 != nil {
			return 0, err11
		}
		i += n11
	}
	return i, nil
}
func (m *Command_DataplaneSoftwareDetails) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataplaneSoftwareDetails != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.DataplaneSoftwareDetails.Size()))
		n12, err12 := m.DataplaneSoftwareDetails.MarshalTo(dAtA[i:])
		if err12 != nil {
			return 0, err12
		}
		i += n12
	}
	return i, nil
}
func (m *Command_DataplaneUpdate) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataplaneUpdate != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.DataplaneUpdate.Size()))
		n13, err13 := m.DataplaneUpdate.MarshalTo(dAtA[i:])
		if err13 != nil {
			return 0, err13
		}
		i += n13
	}
	return i, nil
}
func (m *CommandStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataplaneStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataplaneStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SystemId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.SystemId)))
		i += copy(dAtA[i:], m.SystemId)
	}
	if len(m.Details) > 0 {
		for _, msg := range m.Details {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Host.Size()))
		n14, err14 := m.Host.MarshalTo(dAtA[i:])
		if err14 != nil {
			return 0, err14
		}
		i += n14
	}
	if len(m.Healths) > 0 {
		for _, msg := range m.Healths {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DataplaneSoftwareDetails) > 0 {
		for _, msg := range m.DataplaneSoftwareDetails {
			dAtA[i] = 0x32
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DataplaneSoftwareHealths) > 0 {
		for _, msg := range m.DataplaneSoftwareHealths {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AgentActivityStatus) > 0 {
		for _, msg := range m.AgentActivityStatus {
			dAtA[i] = 0x42
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AgentActivityStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AgentActivityStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		nn15, err15 := m.Status.MarshalTo(dAtA[i:])
		if err15 != nil {
			return 0, err15
		}
		i += nn15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AgentActivityStatus_NginxConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NginxConfigStatus != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.NginxConfigStatus.Size()))
		n16, err16 := m.NginxConfigStatus.MarshalTo(dAtA[i:])
		if err16 != nil {
			return 0, err16
		}
		i += n16
	}
	return i, nil
}
func (m *NginxConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NginxConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CorrelationId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.CorrelationId)))
		i += copy(dAtA[i:], m.CorrelationId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Status))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.NginxId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.NginxId)))
		i += copy(dAtA[i:], m.NginxId)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataplaneSoftwareHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataplaneSoftwareHealth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Health != nil {
		nn17, err17 := m.Health.MarshalTo(dAtA[i:])
		if err17 != nil {
			return 0, err17
		}
		i += nn17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataplaneSoftwareHealth_NginxHealth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NginxHealth != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.NginxHealth.Size()))
		n18, err18 := m.NginxHealth.MarshalTo(dAtA[i:])
		if err18 != nil {
			return 0, err18
		}
		i += n18
	}
	return i, nil
}
func (m *DataplaneSoftwareHealth_AppProtectWafHealth) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AppProtectWafHealth != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.AppProtectWafHealth.Size()))
		n19, err19 := m.AppProtectWafHealth.MarshalTo(dAtA[i:])
		if err19 != nil {
			return 0, err19
		}
		i += n19
	}
	return i, nil
}
func (m *DataplaneUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataplaneUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Host != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Host.Size()))
		n20, err20 := m.Host.MarshalTo(dAtA[i:])
		if err20 != nil {
			return 0, err20
		}
		i += n20
	}
	if len(m.DataplaneSoftwareDetails) > 0 {
		for _, msg := range m.DataplaneSoftwareDetails {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCommand(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Meta.Size()))
		n21, err21 := m.Meta.MarshalTo(dAtA[i:])
		if err21 != nil {
			return 0, err21
		}
		i += n21
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NginxConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NginxConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Status.Size()))
		n22, err22 := m.Status.MarshalTo(dAtA[i:])
		if err22 != nil {
			return 0, err22
		}
		i += n22
	}
	if m.Action != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Action))
	}
	if m.ConfigData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.ConfigData.Size()))
		n23, err23 := m.ConfigData.MarshalTo(dAtA[i:])
		if err23 != nil {
			return 0, err23
		}
		i += n23
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Meta.Size()))
		n24, err24 := m.Meta.MarshalTo(dAtA[i:])
		if err24 != nil {
			return 0, err24
		}
		i += n24
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Status))
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn25, err25 := m.Chunk.MarshalTo(dAtA[i:])
		if err25 != nil {
			return 0, err25
		}
		i += nn25
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataChunk_Header) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Header.Size()))
		n26, err26 := m.Header.MarshalTo(dAtA[i:])
		if err26 != nil {
			return 0, err26
		}
		i += n26
	}
	return i, nil
}
func (m *DataChunk_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Data.Size()))
		n27, err27 := m.Data.MarshalTo(dAtA[i:])
		if err27 != nil {
			return 0, err27
		}
		i += n27
	}
	return i, nil
}
func (m *ChunkedResourceHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkedResourceHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Meta.Size()))
		n28, err28 := m.Meta.MarshalTo(dAtA[i:])
		if err28 != nil {
			return 0, err28
		}
		i += n28
	}
	if m.Chunks != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Chunks))
	}
	if len(m.Checksum) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.ChunkSize))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChunkedResourceChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkedResourceChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.Meta.Size()))
		n29, err29 := m.Meta.MarshalTo(dAtA[i:])
		if err29 != nil {
			return 0, err29
		}
		i += n29
	}
	if m.ChunkId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCommand(dAtA, i, uint64(m.ChunkId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCommand(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCommand(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Command) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCommand(uint64(m.Type))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Command_CmdStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdStatus != nil {
		l = m.CmdStatus.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_NginxConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NginxConfig != nil {
		l = m.NginxConfig.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_NginxConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NginxConfigResponse != nil {
		l = m.NginxConfigResponse.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_AgentConnectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentConnectRequest != nil {
		l = m.AgentConnectRequest.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_AgentConnectResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentConnectResponse != nil {
		l = m.AgentConnectResponse.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_AgentConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentConfigRequest != nil {
		l = m.AgentConfigRequest.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_AgentConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AgentConfig != nil {
		l = m.AgentConfig.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_DataplaneStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataplaneStatus != nil {
		l = m.DataplaneStatus.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_EventReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EventReport != nil {
		l = m.EventReport.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_DataplaneSoftwareDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataplaneSoftwareDetails != nil {
		l = m.DataplaneSoftwareDetails.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *Command_DataplaneUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataplaneUpdate != nil {
		l = m.DataplaneUpdate.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *CommandStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCommand(uint64(m.Status))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovCommand(uint64(m.ErrorCode))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataplaneStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SystemId)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if len(m.Healths) > 0 {
		for _, e := range m.Healths {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if len(m.DataplaneSoftwareDetails) > 0 {
		for _, e := range m.DataplaneSoftwareDetails {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if len(m.DataplaneSoftwareHealths) > 0 {
		for _, e := range m.DataplaneSoftwareHealths {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if len(m.AgentActivityStatus) > 0 {
		for _, e := range m.AgentActivityStatus {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentActivityStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		n += m.Status.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AgentActivityStatus_NginxConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NginxConfigStatus != nil {
		l = m.NginxConfigStatus.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *NginxConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CorrelationId)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCommand(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	l = len(m.NginxId)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataplaneSoftwareHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Health != nil {
		n += m.Health.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataplaneSoftwareHealth_NginxHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NginxHealth != nil {
		l = m.NginxHealth.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *DataplaneSoftwareHealth_AppProtectWafHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppProtectWafHealth != nil {
		l = m.AppProtectWafHealth.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *DataplaneUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if len(m.DataplaneSoftwareDetails) > 0 {
		for _, e := range m.DataplaneSoftwareDetails {
			l = e.Size()
			n += 1 + l + sovCommand(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NginxConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovCommand(uint64(m.Action))
	}
	if m.ConfigData != nil {
		l = m.ConfigData.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCommand(uint64(m.Status))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataChunk_Header) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *DataChunk_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	return n
}
func (m *ChunkedResourceHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.Chunks != 0 {
		n += 1 + sovCommand(uint64(m.Chunks))
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovCommand(uint64(m.ChunkSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChunkedResourceChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.ChunkId != 0 {
		n += 1 + sovCommand(uint64(m.ChunkId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovCommand(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCommand(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCommand(x uint64) (n int) {
	return sovCommand(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Command_CommandType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandStatusResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_CmdStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NginxConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_NginxConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxConfigResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NginxConfigResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_NginxConfigResponse{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConnectRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AgentConnectRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_AgentConnectRequest{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConnectResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AgentConnectResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_AgentConnectResponse{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConfigRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AgentConfigRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_AgentConfigRequest{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AgentConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_AgentConfig{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataplaneStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_DataplaneStatus{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &events.EventReport{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_EventReport{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneSoftwareDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataplaneSoftwareDetails{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_DataplaneSoftwareDetails{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataplaneUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Command_DataplaneUpdate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CommandStatusResponse_CommandStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= CommandStatusResponse_CommandErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataplaneStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataplaneStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataplaneStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &NginxDetails{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &HostInfo{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Healths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Healths = append(m.Healths, &NginxHealth{})
			if err := m.Healths[len(m.Healths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneSoftwareDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataplaneSoftwareDetails = append(m.DataplaneSoftwareDetails, &DataplaneSoftwareDetails{})
			if err := m.DataplaneSoftwareDetails[len(m.DataplaneSoftwareDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneSoftwareHealths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataplaneSoftwareHealths = append(m.DataplaneSoftwareHealths, &DataplaneSoftwareHealth{})
			if err := m.DataplaneSoftwareHealths[len(m.DataplaneSoftwareHealths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentActivityStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentActivityStatus = append(m.AgentActivityStatus, &AgentActivityStatus{})
			if err := m.AgentActivityStatus[len(m.AgentActivityStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentActivityStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentActivityStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentActivityStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxConfigStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NginxConfigStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Status = &AgentActivityStatus_NginxConfigStatus{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NginxConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NginxConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NginxConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CorrelationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= NginxConfigStatus_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NginxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataplaneSoftwareHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataplaneSoftwareHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataplaneSoftwareHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NginxHealth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NginxHealth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Health = &DataplaneSoftwareHealth_NginxHealth{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppProtectWafHealth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppProtectWAFHealth{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Health = &DataplaneSoftwareHealth_AppProtectWafHealth{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataplaneUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataplaneUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataplaneUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &HostInfo{}
			}
			if err := m.Host.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataplaneSoftwareDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataplaneSoftwareDetails = append(m.DataplaneSoftwareDetails, &DataplaneSoftwareDetails{})
			if err := m.DataplaneSoftwareDetails[len(m.DataplaneSoftwareDetails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NginxConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NginxConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NginxConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CommandStatusResponse{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= NginxConfigAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigData == nil {
				m.ConfigData = &ConfigDescriptor{}
			}
			if err := m.ConfigData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= UploadStatus_TransferStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChunkedResourceHeader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &DataChunk_Header{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ChunkedResourceChunk{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &DataChunk_Data{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkedResourceHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkedResourceHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkedResourceHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			m.Chunks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chunks |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkedResourceChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkedResourceChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkedResourceChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &Metadata{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkId", wireType)
			}
			m.ChunkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCommand
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCommand
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCommand(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCommand
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCommand(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCommand
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCommand
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCommand
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCommand
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCommand
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCommand(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCommand
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCommand = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCommand   = fmt.Errorf("proto: integer overflow")
)
